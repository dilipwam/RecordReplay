class PuppeteerTranslator {

    //pass in an options object which can take new languages
    constructor(options) {
        
        // set default values for the keycodes class 
        const defaults = {

            //internal defaults
            recordingTestUrl: "",
            recordingTestID: 0,
            //messaging for code
            standardOpeningComment: "\n\t/*\n" 
            + "\t\t Your options for launching Puppeteer will depend upon your system setup and preferences. \n"
            + "\t\t The following code depends upon you having successfully launched Puppeteer with the reference 'browser'.\n"
            + "\t\t Don't forget to call 'browser.close()' at the end of your tests.\n"
            + "\t*/\n",
            standardRecordingComment: "/*\n" 
            + "\t This is Puppeteer code generated by Record/Replay from a RECORDING. \n"
            + "\t As such it only contains ACTIONS, not ASSERTIONS.\n"
            + "\t If you want to have code with assertions included, you need to generate a replay of this recording and download the replay code.\n"
            + "*/\n\n",
            //puppeteer defaults
            defaultNetworkOffline: false,
            defaultNetworkDownload: -1,
            defaultNetworkUpload: -1,
            defaultLatency: 0

        }
        // create a new object with the defaults over-ridden by the options passed in
        let opts = Object.assign({}, defaults, options);
  
        // assign options to instance data (using only property names contained in defaults object to avoid copying properties we don't want)
        Object.keys(defaults).forEach(prop => { this[prop] = opts[prop]; });
    }

    //FORMATTING FUNCTIONS

    openAnonAsyncFunction = () => `(async () => { \n`

    closeAnonAsyncFunction = () => `\n})();`

    openTimedFunction = () => `\n\tawait new Promise(resolve => window.setTimeout(() => {`

    warnOnIframe = (href) => `\n\t\t//THIS ACTION MUST BE EXECUTED IN CONTEXT OF IFRAME WITH ORIGIN: ${new URL(href).origin}`

    closeTimedFunction = (delay) => `\n\t\tresolve(); \n\t}, ${delay}));\n`

    tabIndex = index =>  index == 0 ? '\n\t' : '\n\t\t';

    //BROWSER CONTROL ACTIONS

    openPage = () => `${this.tabIndex(0)}const page = await browser.newPage();\n`

    navigateToUrl = url => `${this.tabIndex(0)}await page.goto('${url}');\n`

    returnScreenshot = () => `${this.tabIndex(0)}await page.screenshot({path: 'screenshot.png'});\n` 

    closePage = () => `${this.tabIndex(0)}await page.close();\n`

    connectToChromeDevtools = () => `${this.tabIndex(0)}const client = await page.target().createCDPSession();\n` 

    emulateNetworkConditions = (offline = this.defaultNetworkOffline, download = this.defaultNetworkDownload, upload = this.defaultNetworkUpload, latency = this.defaultLatency) => {

        return `${this.tabIndex(0)}await client.send('Network.emulateNetworkConditions', { offline: ${offline}, downloadThroughput: ${download}, uploadThroughput: ${upload}, latency: ${latency} });\n`;

    }

    //ACTION FUNCTIONS

    mouseClick = (selector, clicktype, index) => {
        switch(clicktype) {
            case 'click': return `await page.click('${selector}', { button: 'left', clickCount: 1 } );`
            case 'dblclick': return `await page.click('${selector}', { button: 'left', clickCount: 2 } );`
            case 'contextmenu': return `await page.click('${selector}', { button: 'right', clickCount: 1 } );`
            default: return `${this.tabIndex(index)}//No Click Action Available For Action ${clicktype}`
        }
    }

    recaptcha = (selector) => `await page.click('${selector}', { button: 'left', clickCount: 1 } );`

    //Note you should always focus before you type
    typeText = text => `await page.keyboard.type('${text}');`

    //Note you should always focus before you send key as tab, enter etc may only have meaning in the context of focus
    sendSpecialKey = keyDescriptor => `await page.keyboard.press('${keyDescriptor}');` 

    scrollTo = (xPosition, yPosition) => `await page.evaluate( () => { document.documentElement.scrollTo({ left: ${xPosition}, top: ${yPosition}, behavior: 'smooth' }); });`

    focus = selector => `await page.focus('${selector}');`

    hover = selector => `await page.hover('${selector}');` 

    textSelect = (selector, index) => `await page.evaluate( () => { const event${index} = new Event("selectstart", {view: window, bubbles: true, cancelable: false}); document.querySelector('${selector}').dispatchEvent( event${index} ); });`


    //ASSERTIONS HELPERS, we need to have the index of each item in the Rx.js flow so we can have unique assertions

    getPageTitle = () => `await page.title();`

    querySelector = (selector, index) => `const selected${index} = await page.$('${selector}');` 

    querySelectorAll = (selector, index) => `const selectedAll${index} = await page.$$('${selector}');` 

    countElements = (selector, index) => `const count${index} = await page.$$eval('${selector}', elements => elements.length);`

    getElementProperty = (selector, property, index) => `const ${property}Property${index} = await page.$eval('${selector}', element => element.${property});`

    getElementAttributeValue = (selector, attribute, index) => `const ${attribute}Attribute${index} = await page.$eval('${selector}', element => element.getAttribute('${attribute}');`

    getElementAttributesAsArray = (selector, index) => `const attributesArray${index} = await page.$eval('${selector}', element => Array.prototype.slice.call(element.attributes);`

    getMostValidSelector = recordingEvent => {
        //collect all the existing selectors into an array, filter and return the first valid one
        return [
            recordingEvent.recordingEventCssSelectorPath, 
            recordingEvent.recordingEventCssSimmerPath, 
            recordingEvent.recordingEventCssDomPath
        ]
        //when we filter we need to know what the selectors return when they fail
        .filter(value => value != false && value != 'undefined' && value != null)[0] || ""; 

    }

    mapActionTypeToFunction = (recordingEvent, index) => {
        switch(recordingEvent.recordingEventAction) {
            case "Mouse":
                switch(recordingEvent.recordingEventActionType) {
                    case "hover":
                        return this.hover(this.getMostValidSelector(recordingEvent));
                    case "recaptcha":
                        return this.recaptcha(this.getMostValidSelector(recordingEvent));
                    default:
                        return this.mouseClick(this.getMostValidSelector(recordingEvent), recordingEvent.recordingEventActionType, index);
                }
            case "Scroll":
                return this.scrollTo(recordingEvent.recordingEventXPosition, recordingEvent.recordingEventYPosition);
            case "TextSelect":
                return this.textSelect(this.getMostValidSelector(recordingEvent), index);
            case "Keyboard": 
                return this.sendSpecialKey(recordingEvent.recordingEventKey);
            case 'Input':
                return this.focus(this.getMostValidSelector(recordingEvent)) += this.tabIndex(index) + this.typeText(recordingEvent.recordingEventInputValue);
            case 'Page':
                return `${this.tabIndex(index)}//Page navigate to ${recordingEvent.recordingEventLocationHref}`; 
            default:
                console.log(`No Mapping for Action Type ${recordingEvent.recordingEventAction}`);
                return `${this.tabIndex(index)}//No Mapping Type in Puppeteer for Action ${recordingEvent.recordingEventAction}`; 
        }
    }

    buildRecordingStringFromEvents = recording => {

        //start with an empty string
        var outputString = "";
        //add the standard opening comment
        outputString += this.standardRecordingComment;
        //add the standard async opening function
        outputString += this.openAnonAsyncFunction();
        //add the standard browser warning
        outputString += this.standardOpeningComment;
        //add the open page function
        outputString += this.openPage();
        //open a connection to Chrome DevTools Protocol
        outputString += this.connectToChromeDevtools();
        //set the network conditions
        outputString += this.emulateNetworkConditions(false, recording.recordingTestBandwidthValue, recording.recordingTestBandwidthValue, recording.recordingTestLatencyValue)
        //add the navigate to page function
        outputString += this.navigateToUrl(recording.recordingTestStartUrl);
        //then we loop through the array
        for (let recordingEventIndex in recording.recordingEventArray) { 
            //make sure we have a recording event with defaults
            var eachEvent = new RecordingEvent(recording.recordingEventArray[recordingEventIndex]);
            //if we are on the first event, just push according to event
            if (recordingEventIndex == 0) {
                outputString += `${this.tabIndex(recordingEventIndex)}${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}\n`;
            //otherwise we need to wrap in the setTimeout
            } else {
                //open the async timeout function
                outputString += this.openTimedFunction();
                //then add the iframe warning if required
                eachEvent.recordingEventIsIframe ? outputString += this.warnOnIframe(eachEvent.recordingEventLocationHref) : null;
                //map the action to the function and return string
                outputString += `${this.tabIndex(recordingEventIndex)}${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}`;
                //close the async timeout function
                outputString += this.closeTimedFunction(eachEvent.recordingTimeSincePrevious);
            }
        }
        //add the close page function
        outputString += this.closePage();
        //add the standard async closing function
        outputString += this.closeAnonAsyncFunction();
        //return the string
        return outputString;

    }
  
}