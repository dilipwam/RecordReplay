class PuppeteerTranslator {
    //pass in an options object which can take new languages
    constructor(options) {
        // set default values for the keycodes class
        const defaults = {
            //internal defaults
            recordingTestUrl: '',
            recordingTestID: 0,
            //need a keycode dictionary
            keyCodeDictionary: new KeyCodeDictionary(),
            //messaging for code
            standardOpeningComment:
                '\n\t/*\n' +
                '\t\t Your options for launching Puppeteer will depend upon your system setup and preferences. \n' +
                "\t\t The following code depends upon you having successfully launched Puppeteer with the reference 'browser'.\n" +
                "\t\t Don't forget to call 'browser.close()' at the end of your tests.\n" +
                '\t*/\n',
            standardRecordingComment:
                '/*\n' +
                '\t This is Puppeteer code generated by Record/Replay from a RECORDING. \n' +
                '\t As such it only contains ACTIONS, not ASSERTIONS.\n' +
                '\t If you want to have code with assertions included, you need to generate a replay of this recording and download the replay code.\n' +
                '*/\n\n',
            //puppeteer defaults
            defaultNetworkOffline: false,
            defaultNetworkDownload: -1,
            defaultNetworkUpload: -1,
            defaultLatency: 0,
        };
        // create a new object with the defaults over-ridden by the options passed in
        let opts = Object.assign({}, defaults, options);

        // assign options to instance data (using only property names contained in defaults object to avoid copying properties we don't want)
        Object.keys(defaults).forEach((prop) => {
            this[prop] = opts[prop];
        });
    }

    //FORMATTING FUNCTIONS

    openAnonAsyncFunction = () => `(async () => { \n`;

    closeAnonAsyncFunction = () => `\n})();`;

    openTimedFunction = () => `\n\tawait new Promise(resolve => window.setTimeout(() => {`;

    warnOnIframe = (href) =>
        `\n\t\t//THIS ACTION IS EXECUTED IN CONTEXT OF IFRAME WITH ORIGIN: ${new URL(href).origin}`;

    closeTimedFunction = (delay) => `\n\t\tresolve(); \n\t}, ${delay}));\n`;

    tabIndex = (index) => {
        switch (index) {
            //for the first element in any recording event array, we do not need the timing so we don't need the indentation
            case 0:
                return '\n\t';
            //for one extra tab, we use -1
            case -1:
                return '\n\t\t\t';
            //for two extra tabs we use -2
            case -2:
                return '\n\t\t\t\t';
            //for any element above zero, we use normal tabbing
            default:
                return '\n\t\t';
        }
    };

    //BROWSER CONTROL ACTIONS

    openPage = () => `const page = await browser.newPage();\n`;

    navigateToUrl = (url) => `await page.goto('${url}');\n`;

    returnScreenshot = () => `await page.screenshot({path: 'screenshot.png'});\n`;

    closePage = () => `await page.close();\n`;

    connectToChromeDevtools = () => `const client = await page.target().createCDPSession();\n`;

    emulateNetworkConditions = (
        offline = this.defaultNetworkOffline,
        download = this.defaultNetworkDownload,
        upload = this.defaultNetworkUpload,
        latency = this.defaultLatency
    ) => {
        return `await client.send('Network.emulateNetworkConditions', { offline: ${offline}, downloadThroughput: ${download}, uploadThroughput: ${upload}, latency: ${latency} });\n`;
    };

    emulateDevice = (recording) => {
        //first we need to get a reference to the mobile device list
        const mobileDevices = new MobileDeviceDictionary({});
        //then we need to find our device
        const device = mobileDevices[recording.recordingMobileDeviceId];
        //then we create our orientation object string
        const orientationString =
            recording.recordingMobileOrientation == 'portrait'
                ? "{ angle: 0, type: 'portraitPrimary' }"
                : "{ angle: 90, type: 'landscapePrimary' }";

        return `await client.send('Emulation.setDeviceMetricsOverride', { width: ${device.width}, height: ${device.height}, mobile: true, deviceScaleFactor: 1, screenOrientation: ${orientationString} });\n`;
    };

    //ACTION FUNCTIONS

    mapDispatchKeyEventModifer = (modifier) => {
        switch (modifier) {
            case 1:
                return 'Alt';
            case 2:
                return 'Control';
            case 4:
                return 'Meta';
            case 8:
                return 'Shift';
            default:
                return '';
        }
    };

    mouseClick = (selector, clicktype, index, target) => {
        switch (clicktype) {
            case 'click':
                return `await ${target}.click('${selector}', { button: 'left', clickCount: 1 } );`;
            case 'dblclick':
                return `await ${target}.click('${selector}', { button: 'left', clickCount: 2 } );`;
            case 'contextmenu':
                return `await ${target}.click('${selector}', { button: 'right', clickCount: 1 } );`;
            default:
                return `${this.tabIndex(index)}//No Click Action Available For Action ${clicktype}`;
        }
    };

    recaptcha = (selector, index, target) =>
        `await ${target}.click('${selector}', { button: 'left', clickCount: 1 } );`;

    //we need a parser for the different kinds of input
    inputParser = (selector, recordingEvent, index, target) => {
        //first we need to get the value we need to input
        const value = recordingEvent.recordingEventInputValue;
        //then we need a shorthand for the input type
        const inputType = recordingEvent.recordingEventInputType;
        //then we need to work differently for different kinds of inputs
        switch (true) {
            //if we are talking about a text area element, then we know what we are doing
            case recordingEvent.recordingEventHTMLElement == 'HTMLTextAreaElement':
                //first we have to focus on the element and then we have to type the value
                return `await ${target}.focus('${selector}'); await ${target}.keyboard.type('${value}');`;
            //if we are dealing with an input element, things are a bit more complex
            case recordingEvent.recordingEventHTMLElement == 'HTMLInputElement':
                //then we need to have a detailed method of dealing with the various types of input
                switch (inputType) {
                    //then we need to handle every single input type, starting with those we can handle with a single click
                    case 'checkbox' || 'radio' || 'button' || 'submit' || 'reset':
                        //a simple click will work for the radio buttons and checkboxes
                        return `await ${target}.click(${selector});`;
                    //certain types of text input can all be handled in the same way
                    case 'text' || 'password' || 'url' || 'email' || 'number' || 'search' || 'tel':
                        //first we have to focus on the element and then we have to type the value
                        return `await ${target}.focus('${selector}'); await ${target}.keyboard.type('${value}');`;
                    //then there are special HTML5 inputs that we need to shortcut
                    default:
                        //The <input type="color"> is used for input fields that should contain a color
                        //The <input type="time"> allows the user to select a time (no time zone).
                        //The <input type="date"> is used for input fields that should contain a date.
                        //The <input type="week"> allows the user to select a week and year.
                        //The <input type="month"> allows the user to select a month and year.
                        //The <input type="range"> defines a control for entering a number whose exact value is not important (like a slider control).
                        //FOR ALL THE ABOVE WE SHORTCUT
                        return `await ${target}.evaluate( () => { document.querySelector('${selector}').value = '${value}'; });`;
                }
            //if we are dealing with an select element, puppeteer offers us a nice handler
            case recordingEvent.recordingEventHTMLElement == 'HTMLSelectElement':
                return `await ${target}.select('${selector}', '${value}');`;
            //if we are dealing with a standard HTMLElement with the contenteditable property, then we need to to something slightly different
            case recordingEvent.recordingEventInputType == 'contentEditable':
                //with the content editable, we can't just type in as we have a final text result on blur, so we need to adjust the text directly
                return `await ${target}.evaluate( () => { document.querySelector('${selector}').textContent = '${value}'; });`;
            //then we have a default for when we have no clue
            default:
                return `await ${target}.evaluate( () => { document.querySelector('${selector}').value = '${value}'; });`;
        }
    };

    //Note you should always focus before you send key as tab, enter etc may only have meaning in the context of focus
    nonInputTyping = (selector, replayEvent, index, target) => {
        //so there is some complexity in handling the different types of typing
        //first we need to know if the typing event contains characters or not
        const dictionaryEntry = this.keyCodeDictionary[
            replayEvent.recordingEventDispatchKeyEvent.windowsVirtualKeyCode
        ];
        //then we want to know if there are any modifier keys pressed at the time
        const modifiers = this.mapDispatchKeyEventModifer(replayEvent.recordingEventDispatchKeyEvent.modifiers);
        //then we want to know if the action happened on the main html document or not
        let prependForTarget = '';
        //if the target was not the html, we need to focus
        if (replayEvent.recordingEventHTMLTag != 'HTML') {
            prependForTarget = `await ${target}.focus('${selector}');`;
        }
        //then we need to work on the modifier, if present
        if (modifiers.length > 0) {
            return `${prependForTarget} await page.keyboard.down('${modifiers}'); await page.keyboard.press('${dictionaryEntry.descriptor}'); await page.keyboard.up('${modifiers}');`;
        } else {
            return `${prependForTarget} await page.keyboard.press('${dictionaryEntry.descriptor}');`;
        }
    };

    scrollTo = (xPosition, yPosition, index, target) =>
        `await ${target}.evaluate( () => { document.documentElement.scrollTo({ left: ${xPosition}, top: ${yPosition}, behavior: 'smooth' }); });`;

    elementScrollTo = (selector, xPosition, yPosition, index, target) =>
        `await ${target}.evaluate( () => { document.querySelector('${selector}').scrollTo({ left: ${xPosition}, top: ${yPosition}, behavior: 'smooth' }); });`;

    focus = (selector, target) => `await ${target}.focus('${selector}');`;

    hover = (selector, index, target) => `await ${target}.hover('${selector}');`;

    textSelect = (selector, index, target) =>
        `await ${target}.evaluate( () => { const range${index} = document.createRange(); const referenceNode${index} = document.querySelector('${selector}'); range${index}.selectNode(referenceNode${index}); const currentSelection${index} = window.getSelection(); currentSelection${index}.removeAllRanges(); currentSelection${index}.addRange(range${index}); });`;

    //ASSERTIONS HELPERS, we need to have the index of each item in the Rx.js flow so we can have unique assertions

    getPageUrl = () => 'page.url();';

    getPageTitle = () => `await page.title();`;

    getElementText = (selector, target) => `await ${target}.$eval('${selector}', element => element.textContent);`;

    getVisibleElement = (selector, target) =>
        `await ${target}.waitForSelector('${selector}', { visible: true, timeout: 100 });`;

    querySelector = (selector, target) => `await ${target}.$('${selector}');`;

    querySelectorAll = (selector, target) => `await ${target}.$$('${selector}');`;

    countElements = (selector, target) => `await ${target}.$$eval('${selector}', elements => elements.length);`;

    getElementAttribute = (selector, attribute, target) =>
        `await ${target}.$eval('${selector}', element => element['${attribute}']);`;

    getElementAttributeValue = (selector, attribute, target) =>
        `await ${target}.$eval('${selector}', element => element.getAttribute('${attribute}'));`;

    getElementAttributesAsArray = (selector, target) =>
        `await ${target}.$eval('${selector}', element => Array.prototype.slice.call(element.attributes);`;

    //COMMAND GENERATION FUNCTIONS

    getMostValidSelector = (replayEvent) => {
        //if we have run the replay, we will get a report on the selector that was chosen
        if (replayEvent.replayChosenSelectorString && replayEvent.replayChosenSelectorString.length > 0) {
            return replayEvent.replayChosenSelectorString;
        }
        //if we have run the assertion, we will get a report on the selector that was chosen
        if (replayEvent.assertionChosenSelectorString && replayEvent.assertionChosenSelectorString.length > 0) {
            return replayEvent.assertionChosenSelectorString;
        }
        //otherwise collect all the existing selectors into an array, filter and return the first valid one
        return (
            [
                replayEvent.recordingEventCssSelectorPath,
                replayEvent.recordingEventCssFinderPath,
                replayEvent.recordingEventCssDomPath,
            ]
                //when we filter we need to know what the selectors return when they fail
                .filter(Boolean)[0] || ''
        );
    };

    mapActionTypeToFunction = (recordingEvent, index) => {
        //we have to work out if the recording event has taken place in an iframe because the syntax is different in Puppeteer
        //first we need to create the variable for our target
        let target;
        //then we need to create an array that we can push our strings into then join them at the end
        let outputStringArray = [];
        //then we need to find out if the event has taken place in an iframe
        if (recordingEvent.recordingEventIsIframe) {
            //first we need to get the details of the iframe we are going to be looking for
            const recordingFrameUrl = new URL(recordingEvent.recordingEventLocationHref);
            //then we need to get the origin and the path
            const recordingFrameOrigin = recordingFrameUrl.origin;
            const recordingFramePath = recordingFrameUrl.pathname;
            //then we need to find the frame using the origin and path and allocate it to our indexed frame
            var getFrameString = `const frame${index} = page.frames().find(frame => frame.url().includes('${recordingFrameOrigin}') && frame.url().includes('${recordingFramePath}'));`;
            //then push the frame string to the array
            outputStringArray.push(getFrameString);
            //then we set the target to be the indexed frame
            target = `frame${index}`;
        } else {
            //this is the easy case, the target is just the page
            target = 'page';
        }

        //then we need to determine the type of recording event action so we can deliver the right piece of code to the text area
        switch (recordingEvent.recordingEventAction) {
            //mouse actions can have many variants so we need a subswitch
            case 'Mouse':
                //here we switch on type of action
                switch (recordingEvent.recordingEventActionType) {
                    case 'hover':
                        //in the case of hover, we get the most valid selector and then push the string result of the hover selctor into the array
                        outputStringArray.push(this.hover(this.getMostValidSelector(recordingEvent), index, target));
                        break;
                    case 'recaptcha':
                        //recaptcha is different in recording terms as the event we listen to is not the event we replay - click to replay
                        outputStringArray.push(
                            this.recaptcha(this.getMostValidSelector(recordingEvent), index, target)
                        );
                        break;
                    default:
                        //then we have the default, which handles all the standard clicks, including 'click', 'dblclick' and 'contextmenu'
                        outputStringArray.push(
                            this.mouseClick(
                                this.getMostValidSelector(recordingEvent),
                                recordingEvent.recordingEventActionType,
                                index,
                                target
                            )
                        );
                }
                break;
            //scroll has no particular solution in Puppeteer
            case 'Scroll':
                outputStringArray.push(
                    this.scrollTo(
                        recordingEvent.recordingEventXPosition,
                        recordingEvent.recordingEventYPosition,
                        index,
                        target
                    )
                );
                break;
            case 'ElementScroll':
                outputStringArray.push(
                    this.elementScrollTo(
                        this.getMostValidSelector(recordingEvent),
                        recordingEvent.recordingEventXPosition,
                        recordingEvent.recordingEventYPosition,
                        index,
                        target
                    )
                );
                break;
            //neither does text select
            case 'TextSelect':
                outputStringArray.push(this.textSelect(this.getMostValidSelector(recordingEvent), index, target));
                break;
            case 'Keyboard':
                outputStringArray.push(
                    this.nonInputTyping(this.getMostValidSelector(recordingEvent), recordingEvent, index, target)
                );
                break;
            case 'Input':
                outputStringArray.push(
                    this.inputParser(this.getMostValidSelector(recordingEvent), recordingEvent, index, target)
                );
                break;
            case 'Page':
                //here we just do a simple return with the standard tabbing
                return `${this.tabIndex(0)}// Page navigated to ${recordingEvent.recordingEventLocationHref}`;
            default:
                console.log(`No Mapping for Action Type ${recordingEvent.recordingEventAction}`);
                //here we do a simple return with the indented tabbing so it falls in the same place as the action
                return `${this.tabIndex(index)}//No Mapping Type in Puppeteer for Action ${
                    recordingEvent.recordingEventAction
                }`;
        }

        //then if we reach this point we need to map the string array, with a tabbing element for formatting
        outputStringArray = outputStringArray.map((string) => `${this.tabIndex(index)}${string}`);
        //then we need to return the string
        return outputStringArray.join('');
    };

    buildRecordingStringFromEvents = (recording) => {
        //start with an empty string
        var outputString = '';
        //add the standard opening comment
        outputString += this.standardRecordingComment;
        //add the standard async opening function
        outputString += this.openAnonAsyncFunction();
        //add the standard browser warning
        outputString += this.standardOpeningComment;
        //add the open page function
        outputString += `${this.tabIndex(0)}${this.openPage()}`;
        //open a connection to Chrome DevTools Protocol
        outputString += `${this.tabIndex(0)}${this.connectToChromeDevtools()}`;
        //set the network conditions
        outputString += `${this.tabIndex(0)}${this.emulateNetworkConditions(
            false,
            recording.recordingTestBandwidthValue,
            recording.recordingTestBandwidthValue,
            recording.recordingTestLatencyValue
        )}`;
        //if we have mobile emulation, we need to do that
        if (recording.recordingIsMobile) {
            outputString += `${this.tabIndex(0)}${this.emulateDevice(recording)}`;
        }
        //add the navigate to page function
        outputString += `${this.tabIndex(0)}${this.navigateToUrl(recording.recordingTestStartUrl)}`;
        //then we loop through the array
        for (let recordingEventIndex in recording.recordingEventArray) {
            //make sure we have a recording event with defaults
            var eachEvent = new RecordingEvent(recording.recordingEventArray[recordingEventIndex]);
            //if we are on the first event, just push according to event
            if (recordingEventIndex == 0) {
                outputString += `${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}\n`;
                //otherwise we need to wrap in the setTimeout
            } else {
                //open the async timeout function
                outputString += this.openTimedFunction();
                //then add the iframe warning if required
                eachEvent.recordingEventIsIframe
                    ? (outputString += this.warnOnIframe(eachEvent.recordingEventLocationHref))
                    : null;
                //map the action to the function and return string
                outputString += `${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}`;
                //close the async timeout function
                outputString += this.closeTimedFunction(eachEvent.recordingTimeSincePrevious);
            }
        }
        //add the close page function
        outputString += `${this.tabIndex(0)}${this.closePage()}`;
        //add the standard async closing function
        outputString += this.closeAnonAsyncFunction();
        //return the string
        return outputString;
    };
}
