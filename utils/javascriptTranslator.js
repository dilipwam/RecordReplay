class JavascriptTranslator {

    //pass in an options object which can take new languages
    constructor(options) {
        
        // set default values for the keycodes class 
        const defaults = {

            //internal defaults
            recordingTestUrl: "",
            recordingTestID: 0,
            //messaging for code
            standardRecordingComment: "/*\n" 
            + "\t This is Javascript code generated by Record/Replay from a RECORDING. \n"
            + "\t As such it only contains ACTIONS, not ASSERTIONS.\n"
            + "\t If you want to have code with assertions included, you need to generate a replay of this recording and download the replay code.\n"
            + "*/\n\n"

        }
        // create a new object with the defaults over-ridden by the options passed in
        let opts = Object.assign({}, defaults, options);
  
        // assign options to instance data (using only property names contained in defaults object to avoid copying properties we don't want)
        Object.keys(defaults).forEach(prop => { this[prop] = opts[prop]; });
    }

    //FORMATTING FUNCTIONS

    openAnonAsyncFunction = () => `(async () => { \n`

    closeAnonAsyncFunction = () => `\n})();`
    
    openTimedFunction = () => `\n\tawait new Promise(resolve => window.setTimeout(() => {`

    closeTimedFunction = (delay) => `\n\t\tresolve(); \n\t}, ${delay}));\n`

    tabIndex = index =>  index == 0 ? '\n\t' : '\n\t\t';

    //ACTION FUNCTIONS

    mouseClick = (selector, clicktype, index) => `const event${index} = document.createEvent('Events'); event${index}.initEvent(${clicktype}, true, false); document.querySelector('${selector}').dispatchEvent( event${index} );`

    inputText = (selector, text) => `document.querySelector('${selector}').value = '${text}';` 



    //TO DO Note you should always focus before you send key as tab, enter etc may only have meaning in the context of focus
    // THIS IS NOT WORKING
    sendSpecialKey = (keyCode, index) => `const event${index} = new KeyboardEvent('keydown',{'key': ${keyCode}}); document.querySelector('${selector}').dispatchEvent( event${index} );`



    //TODO - check smooth scroll style key name
    scrollTo = (xPosition, yPosition) => `window.scrollTo({left: ${xPosition}, top: ${yPosition}, behavior: 'smooth'}); `

    focus = (selector, index) => `const event${index} = document.createEvent('Events'); event${index}.initEvent('focus', true, false); document.querySelector('${selector}').dispatchEvent( event${index} );`

    hover = (selector, index) => `const event${index} = document.createEvent('Events'); event${index}.initEvent('mouseover', true, false); document.querySelector('${selector}').dispatchEvent( event${index} );`

    //ASSERTIONS HELPERS

    getTitle = (selector='document', index) => selector == 'document' ? `const title${index} = document.title; ` : `const title${index} = document.querySelector('${selector}').title;`

    querySelector = (selector, index) => `const selected${index} = document.querySelector('${selector}');`

    querySelectorAll = (selector, index) => `const selected${index} = document.querySelectorAll('${selector}');`

    countElements = (selector, index) => `const count${index} = Array.prototype.slice.call(document.querySelectorAll('${selector}')).length;`

    getElementProperty = (selector, property, index) => `const property${index} = document.querySelector('${selector}').${property};`

    getElementAttributeValue = (selector, attribute, index) => `const ${attribute}Attribute${index} = document.querySelector('${selector}').getAttribute('${attribute}');`

    getElementAttributesAsArray = (selector, index) => `const attributesArray${index} = Array.prototype.slice.call(document.querySelector('${selector}').attributes);`

    //RETURN STRING FUNCTIONS

    getMostValidSelector = recordingEvent => {
        //collect all the existing selectors into an array, filter and return the first valid one
        return [
            recordingEvent.recordingEventCssSelectorPath, 
            recordingEvent.recordingEventCssSimmerPath, 
            recordingEvent.recordingEventCssDomPath
        ]
        //when we filter we need to know what the selectors return when they fail
        .filter(value => value != false && value != 'undefined' && value != null)[0] || ""; 

    }

    mapActionTypeToFunction = (recordingEvent, index) => {
        switch(recordingEvent.recordingEventAction) {
            case "Mouse":
                if (recordingEvent.recordingEventActionType == "hover") return this.hover(this.getMostValidSelector(recordingEvent), index);
                if (recordingEvent.recordingEventActionType == "click") return this.hover(this.getMostValidSelector(recordingEvent), recordingEvent.recordingEventActionType, index);
            case "Scroll":
                return this.scrollTo(recordingEvent.recordingEventXPosition, recordingEvent.recordingEventYPosition);
            case "Keyboard": 
                return this.focus(this.getMostValidSelector(recordingEvent), index) += this.tabIndex(index) + this.sendSpecialKey(recordingEvent.recordingEventKeyCode, index);
            case 'Input':
                return this.inputText(this.getMostValidSelector(recordingEvent), recordingEvent.recordingEventInputValue);
            default:
                console.log(`No Mapping for Action Type ${recordingEvent.recordingEventAction}`);
                return `${this.tabIndex(index)}//No Mapping Type for Action ${recordingEvent.recordingEventAction}`; 
        }
    }

    buildRecordingStringFromEvents = eventsArray => {

        //start with an empty string
        var outputString = "";
        //add the standard opening comment
        outputString += this.standardRecordingComment;
        //add the standard async opening function
        outputString += this.openAnonAsyncFunction();
        //then we loop through the array
        for (let recordingEventIndex in eventsArray) { 
            //make sure we have a recording event with defaults
            var eachEvent = new RecordingEvent(eventsArray[recordingEventIndex]);
            //if we are on the first event, just push according to event
            if (recordingEventIndex == 0) {
                outputString += `${this.tabIndex(recordingEventIndex)}${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}\n`;
            //otherwise we need to wrap in the setTimeout
            } else {
                //open the async timeout function
                outputString += this.openTimedFunction();
                //map the action to the function and return string
                outputString += `${this.tabIndex(recordingEventIndex)}${this.mapActionTypeToFunction(eachEvent, recordingEventIndex)}`;
                //close the async timeout function
                outputString += this.closeTimedFunction(eachEvent.recordingTimeSincePrevious);
            }
        }
        //add the standard async closing function
        outputString += this.closeAnonAsyncFunction();
        //return the string
        return outputString;

    }
}